# OS_2
*과제개요

SSUShell 구현은 Linux에서 기본적으로 제공하는 bash 쉘과 유사한 SSUShell을 직접 구현해보고, Linux의 내장 명령어 ps, top와 유사한 명령어인 pps, ttop를 직접 구현해보면서 Linux의 간단한 내장 명령어 기능과 운영체제의 프로세스 정보들의 기본 개념을 이해한다. SSUShell의 실행 흐름도는 fork를 통해 자식프로세스를 생성하고 자식프로세스는 exec()를 호출하여 입력받은 사용자 명령을 실행하는 것으로, 이때 부모프로세스는 wait()을 통해 자식프로세스의 종료를 기다리고 수거하도록 한다. SSUShell은 ‘대화식’ 또는 ‘배치(일괄처리)식’으로 실행된다. ‘대화식’은 SSUShell을 실행하고 원하는 명령어를 계속 입력받아 실행하는 것으로, while문을 통해 Crtl + C를 누를 때까지 명령어를 계속 입력받을 수 있도록 한다. ‘배치식 모드’는 구현한 쉘 스크립트를 실행하면서 인자로 파일을 제공하여 해당 파일의 내용을 읽어 파일에 입력된 명령어를 실행하는 것이다. 따라서 배치식 모드에서는 입력받은 파일이 존재하는지를 먼저 확인하도록 하고, fgets를 통해 파일의 입력된 내용들을 한 줄씩 실행하도록 한다. 해당 파일의 모든 내용을 읽어와 수행한 후에는 종료한다. 입력받은 모든 명령어들은 공백을 기준으로 구분하여 토큰화를 한다. 토큰화된 명령어들은 exec()를 사용할 때 간편하게 사용할 수 있다. 
SSUShell에서 가장 중요한 기능은 파이프로, 파이프는 입출력 파일디스크립터를 제어하면서 파이프를 기준으로 명령어들을 연결해주는 것이다. pipe()를 통해 생성된 파일디스크립터들을 fork하여 생성된 자식프로세스들에게서 dup2를 이용하여 입출력 파일디스크립터들을 연결한 뒤, execv()를 호출하여 명령어를 수행한다. 
명령어를 수행하기 위해 계속 fork로 자식프로세스를 생성하다보니 부모프로세스는 자식프로세스가 정상적으로 종료되었는지, 좀비 프로세스가 없는지도 확인해야 한다.
ttop와 pps는 내장명령어인 top와 ps의 기능과 유사한 기능들을 갖고 있는 것으로 프로세스의 pid, cpu사용량, 메모리사용량 등의 정보들을 한눈에 파악할 수 있다. 또한 옵션을 통해서 출력되는 정보들도 달라진다. 
